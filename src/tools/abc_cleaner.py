#!/usr/bin/env python3
"""
ç®€åŒ–ç‰ˆABCéŸ³ä¹åŽå¤„ç†å·¥å…·
ä¿®å¤ç”Ÿæˆçš„ABCè®°è°±æ ¼å¼ä¸­çš„å¸¸è§é—®é¢˜
"""

import re

def clean_abc_notation(abc_text, title="Generated Music"):
    """
    æ¸…ç†å’Œä¿®å¤ABCè®°è°±æ ¼å¼
    """
    lines = abc_text.split('\n')
    cleaned_lines = []
    has_header = False
    
    # æ£€æŸ¥æ˜¯å¦æœ‰æ­£ç¡®çš„å¤´éƒ¨ä¿¡æ¯
    header_pattern = r'^[XTCMLK]:'
    for line in lines:
        if re.match(header_pattern, line.strip()):
            has_header = True
            break
    
    # å¦‚æžœæ²¡æœ‰å¤´éƒ¨ä¿¡æ¯ï¼Œæ·»åŠ æ ‡å‡†å¤´éƒ¨
    if not has_header:
        standard_header = f"""X:1
T:{title}
C:Generated by HoyoMusic AI
M:4/4
L:1/8
K:C major"""
        cleaned_lines.extend(standard_header.split('\n'))
    
    # å¤„ç†æ¯ä¸€è¡Œ
    for line in lines:
        line = line.strip()
        if not line:
            continue
        
        # å¦‚æžœæ˜¯å¤´éƒ¨ä¿¡æ¯è¡Œï¼Œç›´æŽ¥æ·»åŠ 
        if re.match(header_pattern, line):
            cleaned_lines.append(line)
        else:
            # æ¸…ç†éŸ³ä¹å†…å®¹è¡Œ
            cleaned_line = clean_music_line(line)
            if cleaned_line:
                cleaned_lines.append(cleaned_line)
    
    # ç¡®ä¿éŸ³ä¹ä»¥é€‚å½“çš„ç»“æŸç¬¦ç»“å°¾
    result = '\n'.join(cleaned_lines)
    if not result.endswith('|]') and not result.endswith(':|'):
        result += ' |]'
    
    return result

def clean_music_line(line):
    """
    æ¸…ç†å•è¡ŒéŸ³ä¹è®°è°±ï¼Œç§»é™¤æ— æ•ˆå­—ç¬¦
    """
    # å®šä¹‰æœ‰æ•ˆçš„ABCè®°è°±å­—ç¬¦
    valid_chars = set('CDEFGABcdefgab^_=\'," |[]():123456789/z-><')
    
    # ç§»é™¤æ— æ•ˆå­—ç¬¦
    cleaned = ''.join(c for c in line if c in valid_chars or c.isspace())
    
    # ä¿®å¤å¸¸è§é—®é¢˜
    cleaned = re.sub(r'\s+', ' ', cleaned)  # è§„èŒƒåŒ–ç©ºæ ¼
    cleaned = re.sub(r'\|+', '|', cleaned)  # ä¿®å¤å¤šé‡å°èŠ‚çº¿
    cleaned = re.sub(r'(\d+)\s+(\d+)', r'\1\2', cleaned)  # ä¿®å¤æ•°å­—é—´çš„ç©ºæ ¼
    
    # ç§»é™¤è¿žç»­çš„æ— æ•ˆå­—ç¬¦ç»„åˆ
    cleaned = re.sub(r'[^A-Ga-gz\|\[\]\d\s\^\_\=\'\,\:\(\)\/\-\>\<]+', '', cleaned)
    
    return cleaned.strip()

def validate_abc_basic(abc_text):
    """
    åŸºæœ¬çš„ABCæ ¼å¼éªŒè¯
    """
    lines = abc_text.split('\n')
    
    # æ£€æŸ¥å¿…éœ€çš„å¤´éƒ¨å­—æ®µ
    required_fields = ['X:', 'T:', 'K:']
    found_fields = []
    
    for line in lines:
        for field in required_fields:
            if line.strip().startswith(field):
                found_fields.append(field)
                break
    
    missing_fields = [f for f in required_fields if f not in found_fields]
    
    if missing_fields:
        return False, f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {', '.join(missing_fields)}"
    
    return True, "åŸºæœ¬éªŒè¯é€šè¿‡"

def fix_abc_structure(abc_text, title="Generated Music"):
    """
    ä¿®å¤ABCç»“æž„é—®é¢˜
    """
    try:
        # åŸºæœ¬æ¸…ç†
        cleaned = clean_abc_notation(abc_text, title)
        
        # éªŒè¯
        is_valid, message = validate_abc_basic(cleaned)
        
        if is_valid:
            print("âœ… ABCæ ¼å¼éªŒè¯é€šè¿‡")
        else:
            print(f"âš ï¸ ABCæ ¼å¼é—®é¢˜: {message}")
        
        return cleaned
        
    except Exception as e:
        print(f"âŒ ABCä¿®å¤å¤±è´¥: {e}")
        # è¿”å›žæœ€å°å¯ç”¨çš„ABC
        fallback = f"""X:1
T:{title}
C:Generated by HoyoMusic AI
M:4/4
L:1/8
K:C major
z4|z4|z4|z4|]"""
        return fallback

# æµ‹è¯•å‡½æ•°
if __name__ == "__main__":
    print("ðŸ§ª æµ‹è¯•ABCæ¸…ç†å·¥å…·...")
    
    # æµ‹è¯•ç”¨çš„é—®é¢˜ABC
    test_abc = """X:1
T:Test Music
(|08f:8zF2 62/] F E||CFf1-F[|]c^2GfG[2e] |   e2-4_1xe|D c [|(G2:]xGGcfc][34GGGgz =f"""
    
    print("ðŸ“ åŽŸå§‹ABC:")
    print(test_abc)
    
    cleaned = fix_abc_structure(test_abc, "Test Music")
    
    print("\nðŸ”§ æ¸…ç†åŽABC:")
    print(cleaned)
    
    is_valid, message = validate_abc_basic(cleaned)
    print(f"\nðŸ“‹ éªŒè¯ç»“æžœ: {'âœ…' if is_valid else 'âŒ'} {message}")
